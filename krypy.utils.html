
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>krypy.utils - Krylov Subspace Utilities &mdash; KryPy 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="KryPy 0.1.1 documentation" href="index.html" />
    <link rel="up" title="krypy Package" href="krypy.html" />
    <link rel="next" title="tests Package" href="krypy.tests.html" />
    <link rel="prev" title="krypy.linsys - Linear Algebraic Systems Solver" href="krypy.linsys.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="krypy.tests.html" title="tests Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="krypy.linsys.html" title="krypy.linsys - Linear Algebraic Systems Solver"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">KryPy 0.1.1 documentation</a> &raquo;</li>
          <li><a href="krypy.html" accesskey="U">krypy Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="krypy-utils-krylov-subspace-utilities">
<h1><a class="reference internal" href="#module-krypy.utils" title="krypy.utils"><tt class="xref py py-mod docutils literal"><span class="pre">krypy.utils</span></tt></a> - Krylov Subspace Utilities<a class="headerlink" href="#krypy-utils-krylov-subspace-utilities" title="Permalink to this headline">¶</a></h1>
<p>The utils module provides helper functions for common tasks in the
process of solving linear algebraic systems.</p>
<span class="target" id="module-krypy.utils"></span><p>Collection of standard functions.</p>
<p>This method provides functions like inner products, norms, ...</p>
<dl class="class">
<dt id="krypy.utils.Givens">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">Givens</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.Givens" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Compute Givens rotation for provided vector x.</p>
<p>Computes Givens rotation
<span class="math">\(G=\begin{bmatrix}c&amp;s\\-\overline{s}&amp;c\end{bmatrix}\)</span>
such that
<span class="math">\(Gx=\begin{bmatrix}r\\0\end{bmatrix}\)</span>.</p>
<dl class="method">
<dt id="krypy.utils.Givens.apply">
<tt class="descname">apply</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.Givens.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Givens rotation to vector x.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="krypy.utils.House">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">House</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.House" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Compute Householder transformation for given vector.</p>
<p>Initialize Householder transformation <span class="math">\(H\)</span> such that 
<span class="math">\(Hx = \alpha \|x\|_2 e_1\)</span> with <span class="math">\(|\alpha|=1\)</span></p>
<p>The algorithm is a combination of Algorithm 5.1.1 on page 236
and the treatment of the complex case in Section 5.1.13 on page 243
in Golub, Van Loan. Matrix computations. Fourth Edition. 2013.</p>
<dl class="method">
<dt id="krypy.utils.House.apply">
<tt class="descname">apply</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.House.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Householder transformation to vector x.</p>
<p>Applies the Householder transformation efficiently to the given vector.</p>
</dd></dl>

<dl class="method">
<dt id="krypy.utils.House.matrix">
<tt class="descname">matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#krypy.utils.House.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Build matrix representation of Householder transformation.</p>
<p>Builds the matrix representation
<span class="math">\(H = I - \beta vv^*\)</span>.</p>
<p><strong>Use with care!</strong> This routine may be helpful for testing purposes but
should not be used in production codes for high dimensions since
the resulting matrix is dense.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="krypy.utils.Projection">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">Projection</tt><big>(</big><em>X</em>, <em>Y=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em>, <em>ipYX=None</em>, <em>ipYXinv='explicit'</em><big>)</big><a class="headerlink" href="#krypy.utils.Projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Generic projection.</p>
<p>This class can represent any projection (orthogonal and oblique)
on a N-dimensional Hilbert space. A projection is a linear operator
<span class="math">\(P\)</span> with <span class="math">\(P^2=P\)</span>. A projection is uniquely defined by its
range <span class="math">\(\mathcal{V}:=\operatorname{range}(P)\)</span> and its kernel
<span class="math">\(\mathcal{W}:=\operatorname{ker}(P)\)</span>; this projection is called
<span class="math">\(P_{\mathcal{V},\mathcal{W}}\)</span>.</p>
<p>Let X and Y be two full rank arrays with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt> and let
<span class="math">\(\mathcal{X}\oplus\mathcal{Y}^\perp=\mathbb{C}^N\)</span> where
<span class="math">\(\mathcal{X}:=\operatorname{colspan}(X)\)</span> and
<span class="math">\(\mathcal{Y}:=\operatorname{colspan}(Y)\)</span>.
Then this class constructs the projection
<span class="math">\(P_{\mathcal{X},\mathcal{Y}^\perp}\)</span>.
The requirement
<span class="math">\(\mathcal{X}\oplus\mathcal{Y}^\perp=\mathbb{C}^N\)</span>
is equivalent to <tt class="docutils literal"><span class="pre">inner_product(X,Y)</span></tt> being nonsingular.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt> and
<span class="math">\(\operatorname{rank}(X)=k\)</span>.</li>
<li><strong>Y</strong> &#8211; (optional) <tt class="docutils literal"><span class="pre">None</span></tt> or array with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt> and
<span class="math">\(\operatorname{rank}(X)=k\)</span>. If Y is <tt class="docutils literal"><span class="pre">None</span></tt> then Y is
set to X which means that the resulting projection is orthogonal.</li>
<li><strong>inner_product</strong> &#8211; (optional) the inner product to use, default is
<a class="reference internal" href="#krypy.utils.ip_euclid" title="krypy.utils.ip_euclid"><tt class="xref py py-meth docutils literal"><span class="pre">ip_euclid()</span></tt></a>.</li>
<li><strong>ipYX</strong> &#8211; (optional) <tt class="docutils literal"><span class="pre">None</span></tt> or array with precomputed
<tt class="docutils literal"><span class="pre">inner_product(Y,X)</span></tt> (<tt class="docutils literal"><span class="pre">shape==(k,k)</span></tt>).</li>
<li><strong>ipYXinv</strong> &#8211; <p>(optional) may be one of</p>
<ul>
<li><tt class="docutils literal"><span class="pre">'explicit'</span></tt>: the inverse of <tt class="docutils literal"><span class="pre">ipYX</span></tt> is explicitly computed.</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">'ondemand'</span></tt>: <tt class="docutils literal"><span class="pre">numpy.linalg.solve()</span></tt> is called for each</dt>
<dd>application of the projection.</dd>
</dl>
</li>
<li>array with precomputed inverse of <tt class="docutils literal"><span class="pre">ipYX</span></tt>.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="krypy.utils.Projection.apply">
<tt class="descname">apply</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="#krypy.utils.Projection.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the projection to an array.</p>
<p>The computation is carried out without explicitly forming the
matrix corresponding to the projection (which would be an array with
<tt class="docutils literal"><span class="pre">shape==(N,N)</span></tt>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,m)</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><span class="math">\(P_{\mathcal{X},\mathcal{Y}^\perp} z =
X \langle Y,X\rangle^{-1} \langle Y, z\rangle\)</span>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="krypy.utils.Projection.apply_complement">
<tt class="descname">apply_complement</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="#krypy.utils.Projection.apply_complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the complementary projection to an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,m)</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><span class="math">\(P_{\mathcal{Y}^\perp,\mathcal{X}}z =
z - P_{\mathcal{X},\mathcal{Y}^\perp} z\)</span>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="krypy.utils.Projection.matrix">
<tt class="descname">matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#krypy.utils.Projection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds matrix representation of projection.</p>
<p>Builds the matrix representation
<span class="math">\(P = X \langle Y,X\rangle^{-1} \langle Y, I_N\rangle\)</span>.</p>
<p><strong>Use with care!</strong> This routine may be helpful for testing purposes but
should not be used in production codes for high dimensions since
the resulting matrix is dense.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="krypy.utils.Timer">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">Timer</tt><a class="headerlink" href="#krypy.utils.Timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Measure execution time of multiple code blocks with <tt class="docutils literal"><span class="pre">with</span></tt>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;time me!&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;don</span><span class="se">\&#39;</span><span class="s">t time me!&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;time me, too!&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Result:</p>
<div class="highlight-python"><pre>time me!
don&#x27;t time me!
time me, too!
[6.389617919921875e-05, 6.008148193359375e-05]</pre>
</div>
<p>If you want to measure different types of code blocks you can use
<tt class="docutils literal"><span class="pre">defaultdict</span></tt> as a timer manager:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">tm</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">Timer</span><span class="p">)</span>
<span class="k">with</span> <span class="n">tm</span><span class="p">[</span><span class="s">&#39;class1&#39;</span><span class="p">]:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;code that belongs to class1&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">tm</span><span class="p">[</span><span class="s">&#39;class2&#39;</span><span class="p">]:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;code that belongs to class2&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">tm</span><span class="p">[</span><span class="s">&#39;class1&#39;</span><span class="p">]:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;code that belongs to class1&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>
</pre></div>
</div>
<p>Result:</p>
<div class="highlight-python"><pre>code that belongs to class1
code that belongs to class2
code that belongs to class1
defaultdict(&lt;class krypy.utils.Timer at 0x23810b8&gt;, {&#x27;class2&#x27;: [2.9087066650390625e-05], &#x27;class1&#x27;: [4.696846008300781e-05, 3.2901763916015625e-05]})</pre>
</div>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.angles">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">angles</tt><big>(</big><em>F</em>, <em>G</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em>, <em>compute_vectors=False</em><big>)</big><a class="headerlink" href="#krypy.utils.angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal angles between two subspaces.</p>
<p>This algorithm is based on algorithm 6.2 in <cite>Knyazev, Argentati. Principal
angles between subspaces in an A-based scalar product: algorithms and
perturbation estimates. 2002.</cite> This algorithm can also handle small angles
(in contrast to the naive cosine-based svd algorithm).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>F</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt>.</li>
<li><strong>G</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,l)</span></tt>.</li>
<li><strong>inner_product</strong> &#8211; (optional) angles are computed with respect to this
inner product. Defaults to <a class="reference internal" href="#krypy.utils.ip_euclid" title="krypy.utils.ip_euclid"><tt class="xref py py-meth docutils literal"><span class="pre">ip_euclid()</span></tt></a>.</li>
<li><strong>compute_vectors</strong> &#8211; (optional) if set to <tt class="docutils literal"><span class="pre">False</span></tt> then only the angles
are returned (default). If set to <tt class="docutils literal"><span class="pre">True</span></tt> then also the principal
vectors are returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><tt class="docutils literal"><span class="pre">theta</span></tt> if <tt class="docutils literal"><span class="pre">compute_vectors==False</span></tt></li>
<li><tt class="docutils literal"><span class="pre">theta,</span> <span class="pre">U,</span> <span class="pre">V</span></tt> if <tt class="docutils literal"><span class="pre">compute_vectors==True</span></tt></li>
</ul>
<p>where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">theta</span></tt> is the array with <tt class="docutils literal"><span class="pre">shape==(max(k,l),)</span></tt> containing the
principal angles
<span class="math">\(0\leq\theta_1\leq\ldots\leq\theta_{\max\{k,l\}}\leq
\frac{\pi}{2}\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">U</span></tt> are the principal vectors from F with
<span class="math">\(\langle U,U \rangle=I_k\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">V</span></tt> are the principal vectors from G with
<span class="math">\(\langle V,V \rangle=I_l\)</span>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p>The principal angles and vectors fulfill the relation
<span class="math">\(\langle U,V \rangle =     \begin{bmatrix}     \cos(\Theta) &amp; 0_{m,l-m} \\     0_{k-m,m} &amp; 0_{k-m,l-m}     \end{bmatrix}\)</span>
where <span class="math">\(m=\min\{k,l\}\)</span> and
<span class="math">\(\cos(\Theta)=\operatorname{diag}(\cos(\theta_1),\ldots,\cos(\theta_m))\)</span>.
Furthermore,
<span class="math">\(\theta_{m+1}=\ldots=\theta_{\max\{k,l\}}=\frac{\pi}{2}\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.arnoldi">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">arnoldi</tt><big>(</big><em>A</em>, <em>v</em>, <em>maxiter=None</em>, <em>ortho='mgs'</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.arnoldi" title="Permalink to this definition">¶</a></dt>
<dd><p>Arnoldi algorithm.</p>
<p>Computes V and H such that <span class="math">\(AV_n=V_{n+1}\underline{H}_n\)</span>.
If the Krylov subspace becomes A-invariant then V and H are truncated such
that <span class="math">\(AV_n = V_n H_n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; a linear operator that can be used with scipy&#8217;s aslinearoperator
with <tt class="docutils literal"><span class="pre">shape==(N,N)</span></tt>.</li>
<li><strong>v</strong> &#8211; the initial vector with <tt class="docutils literal"><span class="pre">shape==(N,1)</span></tt>.</li>
<li><strong>maxiter</strong> &#8211; (optional) maximal number of iterations. Default: N.</li>
<li><strong>ortho</strong> &#8211; <p>(optional) orthogonalization algorithm: may be one of</p>
<ul>
<li><tt class="docutils literal"><span class="pre">'mgs'</span></tt>: modified Gram-Schmidt (default).</li>
<li><tt class="docutils literal"><span class="pre">'dmgs'</span></tt>: double Modified Gram-Schmidt.</li>
<li><tt class="docutils literal"><span class="pre">'house'</span></tt>: Householder.</li>
</ul>
</li>
<li><strong>inner_product</strong> &#8211; (optional) the inner product to use (has to be the
Euclidean inner product if <tt class="docutils literal"><span class="pre">ortho=='house'</span></tt>). It&#8217;s unclear to me
(andrenarchy), how a variant of the Householder QR algorithm can be
used with a non-Euclidean inner product. Compare
<a class="reference external" href="http://math.stackexchange.com/questions/433644/is-householder-orthogonalization-qr-practicable-for-non-euclidean-inner-products">http://math.stackexchange.com/questions/433644/is-householder-orthogonalization-qr-practicable-for-non-euclidean-inner-products</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.find_common_dtype">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">find_common_dtype</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#krypy.utils.find_common_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns common dtype of numpy and scipy objects.</p>
<p>Recognizes ndarray, spmatrix and LinearOperator. All other objects are
ignored (most notably None).</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.get_linearoperator">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">get_linearoperator</tt><big>(</big><em>shape</em>, <em>A</em><big>)</big><a class="headerlink" href="#krypy.utils.get_linearoperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Enhances aslinearoperator if A is None.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.hegedus">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">hegedus</tt><big>(</big><em>A</em>, <em>b</em>, <em>x0</em>, <em>M=None</em>, <em>Ml=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.hegedus" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescale initial guess appropriately (Hegedüs trick).</p>
<p>The Hegedüs trick rescales the initial guess to <span class="math">\(\gamma_{\min} x_0\)</span>
such that</p>
<div class="math">
\[\|r_0\|_{M^{-1}}
= \| M M_l (b - A \gamma_{\min} x_0) \|_{M^{-1}}
= \min_{\gamma\in\mathbb{C}} \| M M_l (b - A \gamma x_0) \|_{M^{-1}}
\leq \| M M_l b \|_{M^{-1}}.\]</div>
<p>This is achieved by
<span class="math">\(\gamma_{\min} = \frac{\langle z, M M_l b \rangle_{M^{-1}}}{\|z\|_{M^{-1}}^2}\)</span> for
<span class="math">\(z=M M_l A x_0\)</span> because then <span class="math">\(r_0=P_{z^\perp}b\)</span>. (Note that
the right hand side of formula (5.8.16) in <em>Liesen, Strakos. Krylov
subspace methods. 2013.</em> has to be complex conjugated.)</p>
<p>The parameters are the parameters you want to pass to
<a class="reference internal" href="krypy.linsys.html#krypy.linsys.gmres" title="krypy.linsys.gmres"><tt class="xref py py-meth docutils literal"><span class="pre">gmres()</span></tt></a>,
<a class="reference internal" href="krypy.linsys.html#krypy.linsys.minres" title="krypy.linsys.minres"><tt class="xref py py-meth docutils literal"><span class="pre">minres()</span></tt></a> or
<a class="reference internal" href="krypy.linsys.html#krypy.linsys.cg" title="krypy.linsys.cg"><tt class="xref py py-meth docutils literal"><span class="pre">cg()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the adapted initial guess with the above property.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.ip_euclid">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">ip_euclid</tt><big>(</big><em>X</em>, <em>Y</em><big>)</big><a class="headerlink" href="#krypy.utils.ip_euclid" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean inner product.</p>
<p>numpy.vdot only works for vectors and numpy.dot does not use the conjugate
transpose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; numpy array with <tt class="docutils literal"><span class="pre">shape==(N,m)</span></tt></li>
<li><strong>Y</strong> &#8211; numpy array with <tt class="docutils literal"><span class="pre">shape==(N,n)</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array <span class="math">\(X^* Y\)</span> with <tt class="docutils literal"><span class="pre">shape==(m,n)</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.norm">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">norm</tt><big>(</big><em>x</em>, <em>Mx=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm w.r.t. to a given scalar product.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.norm_MMlr">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">norm_MMlr</tt><big>(</big><em>M</em>, <em>Ml</em>, <em>A</em>, <em>Mr</em>, <em>b</em>, <em>x0</em>, <em>yk</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.norm_MMlr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="krypy.utils.norm_squared">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">norm_squared</tt><big>(</big><em>x</em>, <em>Mx=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.norm_squared" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm^2 w.r.t. to a given scalar product.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.qr">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">qr</tt><big>(</big><em>X</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596dcb0&gt;</em>, <em>reorthos=1</em><big>)</big><a class="headerlink" href="#krypy.utils.qr" title="Permalink to this definition">¶</a></dt>
<dd><p>QR factorization with customizable inner product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt></li>
<li><strong>inner_product</strong> &#8211; (optional) inner product in which the resulting Q
matrix should be orthogonal in. Defaults to <a class="reference internal" href="#krypy.utils.ip_euclid" title="krypy.utils.ip_euclid"><tt class="xref py py-meth docutils literal"><span class="pre">ip_euclid()</span></tt></a>.</li>
<li><strong>reorthos</strong> &#8211; (optional) numer of reorthogonalizations. Defaults to
1 (i.e. 2 runs of modified Gram-Schmidt) which should be enough in most
cases (TODO: add reference).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Q, R where <span class="math">\(X=QR\)</span> with <span class="math">\(\langle Q,Q \rangle=I_k\)</span> and
R upper triangular.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.ritz">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">ritz</tt><big>(</big><em>H</em>, <em>V=None</em>, <em>hermitian=False</em>, <em>type='ritz'</em><big>)</big><a class="headerlink" href="#krypy.utils.ritz" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute several kinds of Ritz pairs from an Arnoldi/Lanczos relation.</p>
<p>This function computes Ritz, harmonic Ritz or improved harmonic Ritz values and
vectors with respect to the Krylov subspace <span class="math">\(K_n(A,v)\)</span> from the
extended Hessenberg matrix <span class="math">\(\underline{H}_n\)</span> generated with n
iterations the Arnoldi algorithm applied to A and v.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>H</strong> &#8211; Hessenberg matrix from Arnoldi/Lanczos algorithm.</li>
<li><strong>V</strong> &#8211; <p>(optional) Arnoldi/Lanczos vectors,
<span class="math">\(V\in\mathbb{C}^{N,n+1}\)</span>. If provided, the Ritz vectors are
also returned. The Arnoldi vectors have to form an orthonormal basis
with respect to an inner product.</p>
<p><strong>Caution:</strong> if you are using the Lanzcos or Gram-Schmidt Arnoldi
algorithm without reorthogonalization, then the orthonormality of the
basis is usually lost. For accurate results it is advisable to use
the Householder Arnoldi (<tt class="docutils literal"><span class="pre">ortho='house'</span></tt>) or modified Gram-Schmidt
with reorthogonalization (<tt class="docutils literal"><span class="pre">ortho='dmgs'</span></tt>).</p>
</li>
<li><strong>hermitian</strong> &#8211; (optional) if set to <tt class="docutils literal"><span class="pre">True</span></tt> the matrix <span class="math">\(H_n\)</span> must
be Hermitian. A Hermitian matrix <span class="math">\(H_n\)</span> allows for faster and
often more accurate computation of Ritz pairs.</li>
<li><strong>type</strong> &#8211; <p>(optional) type of Ritz pairs, may be one of <tt class="docutils literal"><span class="pre">'ritz'</span></tt>,
<tt class="docutils literal"><span class="pre">'harmonic'</span></tt> or <tt class="docutils literal"><span class="pre">'harmonic_like'</span></tt>. Two choices of Ritz pairs fit
in the following description:</p>
<p><cite>Given two n-dimensional subspaces</cite>
<span class="math">\(X,Y\subseteq \mathbb{C}^N\)</span>,
<cite>find a basis</cite>
<span class="math">\(z_1,\ldots,z_n\)</span>
<cite>of</cite>
<span class="math">\(X\)</span>
<cite>and</cite> <span class="math">\(\theta_1,\ldots,\theta_n\in\mathbb{C}\)</span>
such that
<span class="math">\(A z_i - \theta_i z_i \perp Y\)</span>
for all <span class="math">\(i\in\{1,\ldots,n\}\)</span>.</p>
<p>In this setting the choices are</p>
<ul>
<li><tt class="docutils literal"><span class="pre">'ritz'</span></tt>: regular Ritz pairs, i.e. <span class="math">\(X=Y=K_n(A,v)\)</span>.</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">'harmonic'</span></tt>: harmonic Ritz pairs, i.e.</dt>
<dd><span class="math">\(X=K_n(A,v)\)</span> and <span class="math">\(Y=AK_n(A,v)\)</span>.</dd>
</dl>
</li>
<li><tt class="docutils literal"><span class="pre">'harmonic_improved'</span></tt>: the returned vectors <tt class="docutils literal"><span class="pre">U</span></tt> (and <tt class="docutils literal"><span class="pre">V</span></tt>, if
requested) are the same as with <tt class="docutils literal"><span class="pre">type='harmonic'</span></tt>. The <tt class="docutils literal"><span class="pre">theta</span></tt>
array contains the improved Ritz values
<span class="math">\(\theta_i = u_i^* H_n u_i\)</span>, cf. section 2 in <em>Morgan, Zeng.
Harmonic Projection Methods for Large Non-symmetric Eigenvalue
Problems. 1998.</em> It can be shown that the residual norm of improved
Ritz pairs is always less than or equal to the residual norm of the
harmonic Ritz pairs. However, the improved Ritz pairs do not fit into
the framework above since the orthogonality condition is lost.</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li>If V is not <tt class="docutils literal"><span class="pre">None</span></tt> then <tt class="docutils literal"><span class="pre">theta,</span> <span class="pre">U,</span> <span class="pre">resnorm,</span> <span class="pre">Z</span></tt> is returned.</li>
<li>If V is <tt class="docutils literal"><span class="pre">None</span></tt> then <tt class="docutils literal"><span class="pre">theta,</span> <span class="pre">U,</span> <span class="pre">resnorm</span></tt> is returned.</li>
</ul>
<p>Where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">theta</span></tt> are the Ritz values <span class="math">\([\theta_1,\ldots,\theta_n]\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">U</span></tt> are the coefficients of the Ritz vectors in the Arnoldi basis,
i.e. <span class="math">\(z_i=Vu_i\)</span> where <span class="math">\(u_i\)</span> is the i-th column of U.</li>
<li><tt class="docutils literal"><span class="pre">resnorm</span></tt> is a residual norm vector.</li>
<li><tt class="docutils literal"><span class="pre">Z</span></tt> are the actual Ritz vectors, i.e. <tt class="docutils literal"><span class="pre">Z=dot(V,U)</span></tt>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.shape_vec">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">shape_vec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.shape_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a (n,) ndarray and return it as (n,1) ndarray.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.shape_vecs">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">shape_vecs</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#krypy.utils.shape_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape all ndarrays with <tt class="docutils literal"><span class="pre">shape==(n,)</span></tt> to <tt class="docutils literal"><span class="pre">shape==(n,1)</span></tt>.</p>
<p>Recognizes ndarrays and ignores all others.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="krypy.linsys.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">krypy.linsys</span></tt> - Linear Algebraic Systems Solver</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="krypy.tests.html"
                        title="next chapter">tests Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/krypy.utils.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="krypy.tests.html" title="tests Package"
             >next</a> |</li>
        <li class="right" >
          <a href="krypy.linsys.html" title="krypy.linsys - Linear Algebraic Systems Solver"
             >previous</a> |</li>
        <li><a href="index.html">KryPy 0.1.1 documentation</a> &raquo;</li>
          <li><a href="krypy.html" >krypy Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, André Gaul.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
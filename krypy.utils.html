
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>krypy.utils - Krylov Subspace Utilities &mdash; KryPy 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="KryPy 0.1.1 documentation" href="index.html" />
    <link rel="up" title="krypy Package" href="krypy.html" />
    <link rel="next" title="tests Package" href="krypy.tests.html" />
    <link rel="prev" title="krypy.linsys - Linear Algebraic Systems Solver" href="krypy.linsys.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="krypy.tests.html" title="tests Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="krypy.linsys.html" title="krypy.linsys - Linear Algebraic Systems Solver"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">KryPy 0.1.1 documentation</a> &raquo;</li>
          <li><a href="krypy.html" accesskey="U">krypy Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="krypy-utils-krylov-subspace-utilities">
<h1><a class="reference internal" href="#module-krypy.utils" title="krypy.utils"><tt class="xref py py-mod docutils literal"><span class="pre">krypy.utils</span></tt></a> - Krylov Subspace Utilities<a class="headerlink" href="#krypy-utils-krylov-subspace-utilities" title="Permalink to this headline">¶</a></h1>
<p>The utils module provides helper functions for common tasks in the
process of solving linear algebraic systems.</p>
<span class="target" id="module-krypy.utils"></span><p>Collection of standard functions.</p>
<p>This method provides functions like inner products, norms, ...</p>
<dl class="class">
<dt id="krypy.utils.Givens">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">Givens</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.Givens" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Compute Givens rotation for provided vector x.</p>
<p>Computes Givens rotation
<span class="math">\(G=\begin{bmatrix}c&amp;s\\-\overline{s}&amp;c\end{bmatrix}\)</span>
such that
<span class="math">\(Gx=\begin{bmatrix}r\\0\end{bmatrix}\)</span>.</p>
<dl class="method">
<dt id="krypy.utils.Givens.apply">
<tt class="descname">apply</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.Givens.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Givens rotation to vector x.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="krypy.utils.House">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">House</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.House" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Compute Householder transformation for given vector.</p>
<p>Initialize Householder transformation <span class="math">\(H\)</span> such that 
<span class="math">\(Hx = \alpha \|x\|_2 e_1\)</span> with <span class="math">\(|\alpha|=1\)</span></p>
<p>The algorithm is a combination of Algorithm 5.1.1 on page 236
and the treatment of the complex case in Section 5.1.13 on page 243
in Golub, Van Loan. Matrix computations. Fourth Edition. 2013.</p>
<dl class="method">
<dt id="krypy.utils.House.apply">
<tt class="descname">apply</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.House.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Householder transformation to vector x.</p>
<p>Applies the Householder transformation efficiently to the given vector.</p>
</dd></dl>

<dl class="method">
<dt id="krypy.utils.House.matrix">
<tt class="descname">matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#krypy.utils.House.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Build matrix representation of Householder transformation.</p>
<p>Builds the matrix representation
<span class="math">\(H = I - \beta vv^*\)</span>.</p>
<p><strong>Use with care!</strong> This routine may be helpful for testing purposes but
should not be used in production codes for high dimensions since
the resulting matrix is dense.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="krypy.utils.Projection">
<em class="property">class </em><tt class="descclassname">krypy.utils.</tt><tt class="descname">Projection</tt><big>(</big><em>X</em>, <em>Y=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em>, <em>ipYX=None</em>, <em>ipYXinv='explicit'</em><big>)</big><a class="headerlink" href="#krypy.utils.Projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Generic projection.</p>
<p>This class can represent any projection (orthogonal and oblique)
on a N-dimensional Hilbert space. A projection is a linear operator
<span class="math">\(P\)</span> with <span class="math">\(P^2=P\)</span>. A projection is uniquely defined by its
range <span class="math">\(\mathcal{V}:=\operatorname{range}(P)\)</span> and its kernel
<span class="math">\(\mathcal{W}:=\operatorname{ker}(P)\)</span>; this projection is called
<span class="math">\(P_{\mathcal{V},\mathcal{W}}\)</span>.</p>
<p>Let X and Y be two full rank arrays with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt> and let
<span class="math">\(\mathcal{X}\oplus\mathcal{Y}^\perp=\mathbb{C}^N\)</span> where
<span class="math">\(\mathcal{X}:=\operatorname{colspan}(X)\)</span> and
<span class="math">\(\mathcal{Y}:=\operatorname{colspan}(Y)\)</span>.
Then this class constructs the projection
<span class="math">\(P_{\mathcal{X},\mathcal{Y}^\perp}\)</span>.
The requirement
<span class="math">\(\mathcal{X}\oplus\mathcal{Y}^\perp=\mathbb{C}^N\)</span>
is equivalent to <tt class="docutils literal"><span class="pre">inner_product(X,Y)</span></tt> being nonsingular.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt> and
<span class="math">\(\operatorname{rank}(X)=k\)</span>.</li>
<li><strong>Y</strong> &#8211; (optional) <tt class="docutils literal"><span class="pre">None</span></tt> or array with <tt class="docutils literal"><span class="pre">shape==(N,k)</span></tt> and
<span class="math">\(\operatorname{rank}(X)=k\)</span>. If Y is <tt class="docutils literal"><span class="pre">None</span></tt> then Y is
set to X which means that the resulting projection is orthogonal.</li>
<li><strong>inner_product</strong> &#8211; (optional) the inner product to use, default is
<a class="reference internal" href="#krypy.utils.ip_euclid" title="krypy.utils.ip_euclid"><tt class="xref py py-meth docutils literal"><span class="pre">ip_euclid()</span></tt></a>.</li>
<li><strong>ipYX</strong> &#8211; (optional) <tt class="docutils literal"><span class="pre">None</span></tt> or array with precomputed
<tt class="docutils literal"><span class="pre">inner_product(Y,X)</span></tt> (<tt class="docutils literal"><span class="pre">shape==(k,k)</span></tt>).</li>
<li><strong>ipYXinv</strong> &#8211; <p>(optional) may be one of</p>
<ul>
<li><tt class="docutils literal"><span class="pre">'explicit'</span></tt>: the inverse of <tt class="docutils literal"><span class="pre">ipYX</span></tt> is explicitly computed.</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">'ondemand'</span></tt>: <tt class="docutils literal"><span class="pre">numpy.linalg.solve()</span></tt> is called for each</dt>
<dd>application of the projection.</dd>
</dl>
</li>
<li>array with precomputed inverse of <tt class="docutils literal"><span class="pre">ipYX</span></tt>.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="krypy.utils.Projection.apply">
<tt class="descname">apply</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="#krypy.utils.Projection.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the projection to an array.</p>
<p>The computation is carried out without explicitly forming the
matrix corresponding to the projection (which would be an array with
<tt class="docutils literal"><span class="pre">shape==(N,N)</span></tt>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,m)</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><span class="math">\(P_{\mathcal{X},\mathcal{Y}^\perp} z =
X \langle Y,X\rangle^{-1} \langle Y, z\rangle\)</span>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="krypy.utils.Projection.apply_complement">
<tt class="descname">apply_complement</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="#krypy.utils.Projection.apply_complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the complementary projection to an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> &#8211; array with <tt class="docutils literal"><span class="pre">shape==(N,m)</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><span class="math">\(P_{\mathcal{Y}^\perp,\mathcal{X}}z =
z - P_{\mathcal{X},\mathcal{Y}^\perp} z\)</span>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="krypy.utils.Projection.matrix">
<tt class="descname">matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#krypy.utils.Projection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds matrix representation of projection.</p>
<p>Builds the matrix representation
<span class="math">\(P = X \langle Y,X\rangle^{-1} \langle Y, I_N\rangle\)</span>.</p>
<p><strong>Use with care!</strong> This routine may be helpful for testing purposes but
should not be used in production codes for high dimensions since
the resulting matrix is dense.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="krypy.utils.angles">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">angles</tt><big>(</big><em>X</em>, <em>Y</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.angles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="krypy.utils.arnoldi">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">arnoldi</tt><big>(</big><em>A</em>, <em>v</em>, <em>maxiter=None</em>, <em>ortho='mgs'</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.arnoldi" title="Permalink to this definition">¶</a></dt>
<dd><p>Arnoldi algorithm.</p>
<p>Computes V and H such that <span class="math">\(AV_n=V_{n+1}\underline{H}_n\)</span>.
If the Krylov subspace becomes A-invariant then V and H are truncated such
that <span class="math">\(AV_n = V_n H_n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; a linear operator that can be used with scipy&#8217;s aslinearoperator
with <tt class="docutils literal"><span class="pre">shape==(N,N)</span></tt>.</li>
<li><strong>v</strong> &#8211; the initial vector with <tt class="docutils literal"><span class="pre">shape==(N,1)</span></tt>.</li>
<li><strong>maxiter</strong> &#8211; (optional) maximal number of iterations. Default: N.</li>
<li><strong>ortho</strong> &#8211; <p>(optional) orthogonalization algorithm: may be one of</p>
<ul>
<li><tt class="docutils literal"><span class="pre">'mgs'</span></tt>: modified Gram-Schmidt (default).</li>
<li><tt class="docutils literal"><span class="pre">'dmgs'</span></tt>: double Modified Gram-Schmidt.</li>
<li><tt class="docutils literal"><span class="pre">'house'</span></tt>: Householder.</li>
</ul>
</li>
<li><strong>inner_product</strong> &#8211; (optional) the inner product to use (has to be the
Euclidean inner product if <tt class="docutils literal"><span class="pre">ortho=='house'</span></tt>). It&#8217;s unclear to me
(andrenarchy), how a variant of the Householder QR algorithm can be
used with a non-Euclidean inner product. Compare
<a class="reference external" href="http://math.stackexchange.com/questions/433644/is-householder-orthogonalization-qr-practicable-for-non-euclidean-inner-products">http://math.stackexchange.com/questions/433644/is-householder-orthogonalization-qr-practicable-for-non-euclidean-inner-products</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.find_common_dtype">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">find_common_dtype</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#krypy.utils.find_common_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns common dtype of numpy and scipy objects.</p>
<p>Recognizes ndarray, spmatrix and LinearOperator. All other objects are
ignored (most notably None).</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.get_linearoperator">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">get_linearoperator</tt><big>(</big><em>shape</em>, <em>A</em><big>)</big><a class="headerlink" href="#krypy.utils.get_linearoperator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="krypy.utils.get_projection">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">get_projection</tt><big>(</big><em>b</em>, <em>W</em>, <em>AW</em>, <em>x0=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.get_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Get projection and appropriate initial guess for use in deflated methods.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><p class="first">W:  the basis vectors used for deflation (Nxk array).
AW: A*W, where A is the operator of the linear algebraic system to be</p>
<blockquote>
<div>deflated. A has to be self-adjoint w.r.t. inner_product. Do not
include the positive-definite preconditioner (argument M in MINRES)
here. Let N be the dimension of the vector space the operator is
defined on.</div></blockquote>
<p>b:  the right hand side of the linear system (array of length N).
x0: the initial guess (array of length N).
inner_product: the inner product also used for the deflated iterative</p>
<blockquote class="last">
<div>method.</div></blockquote>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>P:  the projection to be used as _right_ preconditioner (e.g. Mr=P in</dt>
<dd>MINRES). The preconditioned operator A*P is self-adjoint w.r.t.
inner_product.
P(x)=x - W*inner_product(W, A*W)^{-1}*inner_product(A*W, x)</dd>
<dt>x0new: an adapted initial guess s.t. the deflated iterative solver</dt>
<dd>does not break down (in exact arithmetics).</dd>
<dt>AW: AW=A*W. This is returned in order to reduce the total number of</dt>
<dd>matrix-vector multiplications with A.</dd>
</dl>
</dd>
</dl>
<p>For nW = W.shape[1] = AW.shape[1] the computational cost is
cost(get_projection): 2*cost(Pfun) + (nW^2)*IP
cost(Pfun): nW*IP + (2/3)*nW^3 + nW*AXPY</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.ip_euclid">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">ip_euclid</tt><big>(</big><em>X</em>, <em>Y</em><big>)</big><a class="headerlink" href="#krypy.utils.ip_euclid" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean inner product.</p>
<p>numpy.vdot only works for vectors and numpy.dot does not use the conjugate
transpose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; numpy array with <tt class="docutils literal"><span class="pre">shape==(N,m)</span></tt></li>
<li><strong>Y</strong> &#8211; numpy array with <tt class="docutils literal"><span class="pre">shape==(N,n)</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array <span class="math">\(X^* Y\)</span> with <tt class="docutils literal"><span class="pre">shape==(m,n)</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.norm">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">norm</tt><big>(</big><em>x</em>, <em>Mx=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm w.r.t. to a given scalar product.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.norm_MMlr">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">norm_MMlr</tt><big>(</big><em>M</em>, <em>Ml</em>, <em>A</em>, <em>Mr</em>, <em>b</em>, <em>x0</em>, <em>yk</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.norm_MMlr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="krypy.utils.norm_squared">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">norm_squared</tt><big>(</big><em>x</em>, <em>Mx=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.norm_squared" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm^2 w.r.t. to a given scalar product.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.ritz">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">ritz</tt><big>(</big><em>H</em>, <em>V=None</em>, <em>hermitian=False</em>, <em>type='ritz'</em><big>)</big><a class="headerlink" href="#krypy.utils.ritz" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute several kinds of Ritz pairs from an Arnoldi/Lanczos relation.</p>
<p>This function computes Ritz, harmonic Ritz or improved harmonic Ritz values and
vectors with respect to the Krylov subspace <span class="math">\(K_n(A,v)\)</span> from the
extended Hessenberg matrix <span class="math">\(\underline{H}_n\)</span> generated with n
iterations the Arnoldi algorithm applied to A and v.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>H</strong> &#8211; Hessenberg matrix from Arnoldi/Lanczos algorithm.</li>
<li><strong>V</strong> &#8211; <p>(optional) Arnoldi/Lanczos vectors,
<span class="math">\(V\in\mathbb{C}^{N,n+1}\)</span>. If provided, the Ritz vectors are
also returned. The Arnoldi vectors have to form an orthonormal basis
with respect to an inner product.</p>
<p><strong>Caution:</strong> if you are using the Lanzcos or Gram-Schmidt Arnoldi
algorithm without reorthogonalization, then the orthonormality of the
basis is usually lost. For accurate results it is advisable to use
the Householder Arnoldi (<tt class="docutils literal"><span class="pre">ortho='house'</span></tt>) or modified Gram-Schmidt
with reorthogonalization (<tt class="docutils literal"><span class="pre">ortho='dmgs'</span></tt>).</p>
</li>
<li><strong>hermitian</strong> &#8211; (optional) if set to <tt class="docutils literal"><span class="pre">True</span></tt> the matrix <span class="math">\(H_n\)</span> must
be Hermitian. A Hermitian matrix <span class="math">\(H_n\)</span> allows for faster and
often more accurate computation of Ritz pairs.</li>
<li><strong>type</strong> &#8211; <p>(optional) type of Ritz pairs, may be one of <tt class="docutils literal"><span class="pre">'ritz'</span></tt>,
<tt class="docutils literal"><span class="pre">'harmonic'</span></tt> or <tt class="docutils literal"><span class="pre">'harmonic_like'</span></tt>. All choices of Ritz pairs fit
in the following description:</p>
<p><cite>Given two n-dimensional subspaces</cite>
<span class="math">\(X,Y\subseteq \mathbb{C}^N\)</span>,
<cite>find a basis</cite>
<span class="math">\(z_1,\ldots,z_n\)</span>
<cite>of</cite>
<span class="math">\(X\)</span>
<cite>and</cite> <span class="math">\(\theta_1,\ldots,\theta_n\in\mathbb{C}\)</span>
such that
<span class="math">\(A z_i - \theta_i z_i \perp Y\)</span>
for all <span class="math">\(i\in\{1,\ldots,n\}\)</span>.</p>
<p>In this setting the choices are</p>
<ul>
<li><tt class="docutils literal"><span class="pre">'ritz'</span></tt>: regular Ritz pairs, i.e. <span class="math">\(X=Y=K_n(A,v)\)</span>.</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">'harmonic'</span></tt>: harmonic Ritz pairs, i.e.</dt>
<dd><span class="math">\(X=K_n(A,v)\)</span> and <span class="math">\(Y=AK_n(A,v)\)</span>.</dd>
</dl>
</li>
<li><tt class="docutils literal"><span class="pre">'harmonic_improved'</span></tt>: the returned vectors <tt class="docutils literal"><span class="pre">U</span></tt> (and <tt class="docutils literal"><span class="pre">V</span></tt>, if
requested) are the same as with <tt class="docutils literal"><span class="pre">type='harmonic'</span></tt>. The <tt class="docutils literal"><span class="pre">theta</span></tt>
array contains the improved Ritz values
<span class="math">\(\theta_i = u_i^* H_n u_i\)</span>, cf. section 2 in <em>Morgan, Zeng.
Harmonic Projection Methods for Large Non-symmetric Eigenvalue
Problems. 1998.</em></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li>If V is not <tt class="docutils literal"><span class="pre">None</span></tt> then <tt class="docutils literal"><span class="pre">theta,</span> <span class="pre">U,</span> <span class="pre">resnorm,</span> <span class="pre">Z</span></tt> is returned.</li>
<li>If V is <tt class="docutils literal"><span class="pre">None</span></tt> then <tt class="docutils literal"><span class="pre">theta,</span> <span class="pre">U,</span> <span class="pre">resnorm</span></tt> is returned.</li>
</ul>
<p>Where</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">theta</span></tt> are the Ritz values <span class="math">\([\theta_1,\ldots,\theta_n]\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">U</span></tt> are the coefficients of the Ritz vectors in the Arnoldi basis,
i.e. <span class="math">\(z_i=Vu_i\)</span> where <span class="math">\(u_i\)</span> is the i-th column of U.</li>
<li><tt class="docutils literal"><span class="pre">resnorm</span></tt> is a residual norm vector.</li>
<li><tt class="docutils literal"><span class="pre">Z</span></tt> are the actual Ritz vectors, i.e. <tt class="docutils literal"><span class="pre">Z=dot(V,U)</span></tt>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.ritzh">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">ritzh</tt><big>(</big><em>Vfull</em>, <em>Hfull</em>, <em>W=None</em>, <em>AW=None</em>, <em>A=None</em>, <em>M=None</em>, <em>Minv=None</em>, <em>inner_product=&lt;function ip_euclid at 0x2aaab596e8c0&gt;</em><big>)</big><a class="headerlink" href="#krypy.utils.ritzh" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Ritz pairs from a (possibly deflated) Lanczos procedure.</p>
<dl class="docutils">
<dt>Arguments</dt>
<dd><dl class="first docutils">
<dt>W:  a Nxk array. W&#8217;s columns must be orthonormal w.r.t. the</dt>
<dd>M-inner-product (inner_product(M^{-1} W, W) = I_k).</dd>
<dt>AW: contains the result of A applied to W (passed in order to reduce #</dt>
<dd>of matrix-vector multiplications with A).</dd>
<dt>Vfull: a Nxn array. Vfull&#8217;s columns must be orthonormal w.r.t. the</dt>
<dd>M-inner-product. Vfull and Hfull must be created with a (possibly
deflated) Lanczos procedure (e.g. CG/MINRES). For example, Vfull
and Hfull can be obtained from MINRES applied to a linear system
with the operator A, the inner product inner_product, the HPD
preconditioner M and the right preconditioner Mr set to the
projection obtained with get_projection(W, AW, ...).</dd>
</dl>
<p>Hfull: see Vfull.
M:  The preconditioner used in the Lanczos procedure.</p>
<dl class="last docutils">
<dt>The arguments thus have to fulfill the following equations:</dt>
<dd><p class="first">AW = A*W.
M*A*Mr*Vfull[:,0:-1] = Vfull*Hfull,</p>
<blockquote>
<div>where Mr=get_projection(W, AW,...,inner_product).</div></blockquote>
<p class="last">inner_product( M^{-1} [W,Vfull], [W,Vfull] ) = I_{k+n}.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">ritz_vals: an array with n+k Ritz values.
ritz_coeffs: a (n+k)x(n+k) array where the ritz_coeffs[:,i] are the</p>
<blockquote>
<div>coefficients (in the basis [W,Vfull]) of the vector corresponding
the Ritz value ritz_vals[i]. The Ritz vectors then also are
orthonormal w.r.t. the M-inner-product, that is inner_product(
M^{-1}*ritz_vecs, ritz_vecs ) = I_{k+n}.</div></blockquote>
<dl class="last docutils">
<dt>ritz_res_norm: an array with n+k residual norms. ritz_res_norm[i] is</dt>
<dd><dl class="first docutils">
<dt>the M^{-1}-norm of the residual</dt>
<dd>M*A*ritz_vecs[:,i] - ritz_vals[i]*ritz_vecs[:,i].</dd>
</dl>
<p class="last">ritz_vals, ritz_vecs and norm_ritz_res are sorted s.t. the
residual norms are ascending.</p>
</dd>
</dl>
</dd>
</dl>
<p>Under the above assumptions, [W, Vfull] is orthonormal w.r.t. the
M-inner-product. Then the Ritz pairs w.r.t. the operator M*A, the basis [W,
Vfull[:,0:-1]] and the M-inner-product are computed. Also the M-norm of the
Ritz pair residual is computed. The computation of the residual norms do
not need the application of the operator A, but the preconditioner has to
be applied to the basis W. The computation of the residual norm may be
unstable (it seems as if residual norms below 1e-8 cannot be achieved...
note that the actual residual may be lower!).</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.shape_vec">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">shape_vec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#krypy.utils.shape_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a (n,) ndarray and return it as (n,1) ndarray.</p>
</dd></dl>

<dl class="function">
<dt id="krypy.utils.shape_vecs">
<tt class="descclassname">krypy.utils.</tt><tt class="descname">shape_vecs</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#krypy.utils.shape_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape all ndarrays with <tt class="docutils literal"><span class="pre">shape==(n,)</span></tt> to <tt class="docutils literal"><span class="pre">shape==(n,1)</span></tt>.</p>
<p>Recognizes ndarrays and ignores all others.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="krypy.linsys.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">krypy.linsys</span></tt> - Linear Algebraic Systems Solver</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="krypy.tests.html"
                        title="next chapter">tests Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/krypy.utils.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="krypy.tests.html" title="tests Package"
             >next</a> |</li>
        <li class="right" >
          <a href="krypy.linsys.html" title="krypy.linsys - Linear Algebraic Systems Solver"
             >previous</a> |</li>
        <li><a href="index.html">KryPy 0.1.1 documentation</a> &raquo;</li>
          <li><a href="krypy.html" >krypy Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, André Gaul.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>